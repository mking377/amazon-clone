// ===== imports
import { Router, Request, Response, NextFunction } from "express";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import axios from "axios";
import User from "../models/User";
import { loginLimiter } from "../middleware/rateLimiter";

const router = Router();
const JWT_SECRET = process.env.JWT_SECRET || "fallback_secret";
const USER_SERVICE_URL = process.env.USER_SERVICE_URL || "http://localhost:5000";

// ===== Types
export interface AuthRequest extends Request {
  user?: {
    id: string;
    email?: string;
    role?: string;
  };
}

// ===== Middleware Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† JWT
export const requireAuth = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const token = req.cookies?.token || req.headers.authorization?.split(" ")[1];
    console.log("Token received in middleware:", token);
    
    if (!token) return res.status(401).json({ message: "No token provided" });

    const decoded = jwt.verify(token, JWT_SECRET) as { id: string; email: string; role: string };
    console.log("Decoded token:", decoded);

    req.user = decoded;
    next();
  } catch (error) {
    console.error("Auth error:", error);
    res.status(401).json({ message: "Invalid or expired token" });
  }
};

// ===== Register
router.post("/register", async (req: Request, res: Response) => {
  try {
    const { name, email, password, confirmPassword } = req.body;

    if (!name || !email || !password || !confirmPassword)
      return res.status(400).json({ message: "All fields are required" });

    if (password !== confirmPassword)
      return res.status(400).json({ message: "Passwords do not match" });

    const passwordRegex =
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-={}[\]|:;"'<>,.?/]).{8,}$/;
    if (!passwordRegex.test(password))
      return res.status(400).json({
        message:
          "Password must have at least 8 characters, one uppercase, one lowercase, one number, and one special character",
      });

    const existingUser = await User.findOne({ email });
    if (existingUser) return res.status(400).json({ message: "User already exists" });

    const hashedPassword = await bcrypt.hash(password, 10);
    const newUser = new User({ name, email, password: hashedPassword, role: "user" });
    await newUser.save();

    res.status(201).json({ message: "User registered successfully" });
  } catch (error) {
    console.error("Register error:", error);
    res.status(500).json({ message: "Error registering user" });
  }
});

// ===== Login
router.post(
  "/login",
  loginLimiter(),
  async (req: Request, res: Response) => {
    try {
      const { email, password } = req.body;

      const user = await User.findOne({ email });
      if (!user) return res.status(400).json({ message: "Invalid email or password" });

      const isMatch = await bcrypt.compare(password, user.password);
      if (!isMatch) return res.status(400).json({ message: "Invalid email or password" });

     const token = jwt.sign(
  { 
    id: user._id.toString(),  // Ø­ÙˆÙ„ Ø§Ù„Ù€ ObjectId Ø¥Ù„Ù‰ string
    email: user.email, 
    role: user.role 
  },
  JWT_SECRET,
  { algorithm: "HS256", expiresIn: "2h" }
);


/*
      const token = jwt.sign(
        { id: user._id.toString, email: user.email, role: user.role },
        JWT_SECRET,
        { algorithm: "HS256", expiresIn: "2h" }
      );

*/

/*
      const token = jwt.sign(
        { id: user._id, email: user.email, role: user.role },
        JWT_SECRET,
        { expiresIn: "2h" }
      );
*/
      console.log("Generated JWT token:", token);
      // Ø¯Ø§Ø®Ù„ route login Ø¨Ø¹Ø¯ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØªÙˆÙƒÙ†
      console.log("Generated JWT token:", token);
      console.log("Token length:", token.length);
      res.cookie("token", token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "lax",
        maxAge: 2 * 60 * 60 * 1000,
      });

      res.json({
        message: "Login successful",
        user: { id: user._id, name: user.name, email: user.email, role: user.role },
      });
    } catch (error) {
      console.error("Login error:", error);
      res.status(500).json({ message: "Error logging in" });
    }
  }
);

// ===== GET /profile
router.get("/profile", requireAuth, async (req: Request, res: Response) => {
  try {
    const token = req.cookies.token;
    console.log("Token sent to user service:", token);

    if (!token) return res.status(401).json({ message: "No token provided" });

    const headers = { Authorization: `Bearer ${token}` };
    console.log("Axios headers:", headers);

    const response = await axios.get(`${USER_SERVICE_URL}/user/profile`, { headers });
    console.log("User service response:", response.data);

    res.json(response.data);
  } catch (err: any) {
    console.error("Fetch profile error:", err.response?.data || err.message);
    res.status(500).json({ message: "Error fetching profile" });
  }
});

export default router;

// services/auth/routes/auth.ts

/*
// ===== imports
import { Router, Request, Response, NextFunction } from "express";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import axios from "axios";
import User from "../models/User";
import { loginLimiter } from "../middleware/rateLimiter";

const router = Router();
const JWT_SECRET = process.env.JWT_SECRET || "fallback_secret";
const USER_SERVICE_URL = process.env.USER_SERVICE_URL || "http://localhost:5000";

// ===== Types
export interface AuthRequest extends Request {
  user?: {
    id: string;
    email?: string;
    role?: string;
  };
}
// ===== Middleware Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† JWT
export const requireAuth = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const token = req.cookies?.token || req.headers.authorization?.split(" ")[1];
    if (!token) return res.status(401).json({ message: "No token provided" });

    const decoded = jwt.verify(token, JWT_SECRET) as { id: string; email: string; role: string };
    req.user = decoded;
    next();
  } catch (error) {
    console.error("Auth error:", error);
    res.status(401).json({ message: "Invalid or expired token" });
  }
};
// ===== Register
router.post("/register", async (req: Request, res: Response) => {
  try {
    const { name, email, password, confirmPassword } = req.body;

    if (!name || !email || !password || !confirmPassword)
      return res.status(400).json({ message: "All fields are required" });

    if (password !== confirmPassword)
      return res.status(400).json({ message: "Passwords do not match" });

    const passwordRegex =
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-={}[\]|:;"'<>,.?/]).{8,}$/;
    if (!passwordRegex.test(password))
      return res.status(400).json({
        message:
          "Password must have at least 8 characters, one uppercase, one lowercase, one number, and one special character",
      });

    const existingUser = await User.findOne({ email });
    if (existingUser) return res.status(400).json({ message: "User already exists" });

    const hashedPassword = await bcrypt.hash(password, 10);
    const newUser = new User({ name, email, password: hashedPassword, role: "user" });
    await newUser.save();

    res.status(201).json({ message: "User registered successfully" });
  } catch (error) {
    console.error("Register error:", error);
    res.status(500).json({ message: "Error registering user" });
  }
});
// ===== Login
router.post(
  "/login",
  loginLimiter(), // Ø¨Ø¯ÙˆÙ† Ø£ÙŠ arguments
  async (req: Request, res: Response) => {
    try {
      const { email, password } = req.body;

      const user = await User.findOne({ email });
      if (!user) return res.status(400).json({ message: "Invalid email or password" });

      const isMatch = await bcrypt.compare(password, user.password);
      if (!isMatch) return res.status(400).json({ message: "Invalid email or password" });

      const token = jwt.sign(
        { id: user._id, email: user.email, role: user.role },
        JWT_SECRET,
        { expiresIn: "2h" }
      );

      res.cookie("token", token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "lax",
        maxAge: 2 * 60 * 60 * 1000,
      });
      res.json({
        message: "Login successful",
        user: { id: user._id, name: user.name, email: user.email, role: user.role },
      });
    } catch (error) {
      console.error("Login error:", error);
      res.status(500).json({ message: "Error logging in" });
    }
  }
);
router.get("/profile", requireAuth, async (req: Request, res: Response) => {
  try {
    const token = req.cookies.token;
    if (!token) return res.status(401).json({ message: "No token provided" });

    const response = await axios.get(`http://localhost:5000/user/profile`, {
      headers: { Authorization: `Bearer ${token}` }, // Ø£Ø±Ø³Ù„ Ø§Ù„ØªÙˆÙƒÙ† ÙÙŠ Ø§Ù„Ù‡ÙŠØ¯Ø±
    });

    res.json(response.data);
  } catch (err) {
    console.error("Fetch profile error:", err);
    res.status(500).json({ message: "Error fetching profile" });
  }
});


/*

router.get("/profile", requireAuth, async (req: Request, res: Response) => {
  try {
    const response = await axios.get(`${USER_SERVICE_URL}/user/profile`, {
      headers: { Cookie: `token=${req.cookies.token}` },
      withCredentials: true,
    });
    res.json(response.data);
  } catch (err) {
    console.error("Fetch profile error:", err);
    res.status(500).json({ message: "Error fetching profile" });
  }
});
*

/*

// ===== Fetch profile from user service
router.get("/profile/:id", requireAuth, async (req: Request, res: Response) => {
  try {
    const userId = req.params.id;
    const response = await axios.get(`${USER_SERVICE_URL}/profile/${userId}`, {
      withCredentials: true,
    });
    res.json(response.data);
  } catch (err) {
    console.error("Fetch profile error:", err);
    res.status(500).json({ message: "Error fetching profile" });
  }
})
;
*

export default router;



*/




/*


// ===== imports
import { Router, Request, Response, NextFunction } from "express";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import User from "../models/User";
import { loginLimiter } from "../middleware/rateLimiter";

const router = Router();
const JWT_SECRET = process.env.JWT_SECRET || "fallback_secret";

// ===== Types
export interface AuthRequest extends Request {
  user?: {
    id: string;
    email?: string;
    role?: string;
  };
}

// ===== Middleware Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† JWT
export const requireAuth = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const token = req.cookies?.token || req.headers.authorization?.split(" ")[1];
    if (!token) return res.status(401).json({ message: "No token provided" });

    const decoded = jwt.verify(token, JWT_SECRET) as { id: string; email: string; role: string };
    req.user = decoded;
    next();
  } catch (error) {
    console.error("Auth error:", error);
    res.status(401).json({ message: "Invalid or expired token" });
  }
};

// ===== Register
router.post("/register", async (req: Request, res: Response) => {
  try {
    const { name, email, password, confirmPassword } = req.body;

    if (!name || !email || !password || !confirmPassword)
      return res.status(400).json({ message: "All fields are required" });

    if (password !== confirmPassword)
      return res.status(400).json({ message: "Passwords do not match" });

    const passwordRegex =
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-={}[\]|:;"'<>,.?/]).{8,}$/;
    if (!passwordRegex.test(password))
      return res.status(400).json({
        message:
          "Password must have at least 8 characters, one uppercase, one lowercase, one number, and one special character",
      });

    const existingUser = await User.findOne({ email });
    if (existingUser) return res.status(400).json({ message: "User already exists" });

    const hashedPassword = await bcrypt.hash(password, 10);
    const newUser = new User({ name, email, password: hashedPassword, role: "user" });
    await newUser.save();

    res.status(201).json({ message: "User registered successfully" });
  } catch (error) {
    console.error("Register error:", error);
    res.status(500).json({ message: "Error registering user" });
  }
});


// ===== Login
router.post(
  "/login",
  loginLimiter(), // Ø¨Ø¯ÙˆÙ† Ø£ÙŠ arguments
  async (req: Request, res: Response) => {
    try {
      const { email, password } = req.body;

      const user = await User.findOne({ email });
      if (!user) return res.status(400).json({ message: "Invalid email or password" });

      const isMatch = await bcrypt.compare(password, user.password);
      if (!isMatch) return res.status(400).json({ message: "Invalid email or password" });

      const token = jwt.sign(
        { id: user._id, email: user.email, role: user.role },
        JWT_SECRET,
        { expiresIn: "2h" }
      );

      res.cookie("token", token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "lax",
        maxAge: 2 * 60 * 60 * 1000,
      });

      res.json({
        message: "Login successful",
        user: { id: user._id, name: user.name, email: user.email, role: user.role },
      });
    } catch (error) {
      console.error("Login error:", error);
      res.status(500).json({ message: "Error logging in" });
    }
  }
);


*/


/*

// ===== Login
router.post(
  "/login",
  (req, res, next) => loginLimiter(req.query.locale as string)(req, res, next),
  async (req: Request, res: Response) => {
    try {
      const { email, password } = req.body;

      const user = await User.findOne({ email });
      if (!user) return res.status(400).json({ message: "Invalid email or password" });

      const isMatch = await bcrypt.compare(password, user.password);
      if (!isMatch) return res.status(400).json({ message: "Invalid email or password" });

      const token = jwt.sign(
        { id: user._id, email: user.email, role: user.role },
        JWT_SECRET,
        { expiresIn: "2h" }
      );

      res.cookie("token", token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "lax",
        maxAge: 2 * 60 * 60 * 1000,
      });

      res.json({
        message: "Login successful",
        user: { id: user._id, name: user.name, email: user.email, role: user.role },
      });
    } catch (error) {
      console.error("Login error:", error);
      res.status(500).json({ message: "Error logging in" });
    }
  }
);

***

export default router;


*/

/*

// ===== imports
import { Router, Request, Response, NextFunction } from "express";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import crypto from "crypto";
import User from "../models/User";

import { loginLimiter, forgotPasswordLimiter, resetPasswordLimiter } from "../middleware/rateLimiter";


router.post("/login", (req, res, next) => loginLimiter(req.query.locale as string)(req, res, next), async (req, res) => {
  // login logic
});

router.post("/forgot-password", (req, res, next) => forgotPasswordLimiter(req.query.locale as string)(req, res, next), async (req, res) => {
  // forgot password logic
});

router.post("/reset-password", (req, res, next) => resetPasswordLimiter(req.query.locale as string)(req, res, next), async (req, res) => {
  // reset password logic
});

export default router;
const router = Router();
const JWT_SECRET = process.env.JWT_SECRET || "fallback_secret";

// ===== Middleware Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† JWT
// ===== Middleware ÙˆØ§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† JWT + Change Password
export interface AuthRequest extends Request {
  user?: {
    id: string;
    email?: string;
    role?: string;
  };
}

export const requireAuth = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const token = req.cookies?.token || req.headers.authorization?.split(" ")[1];
    if (!token) return res.status(401).json({ message: "No token provided" });

    const decoded = jwt.verify(token, JWT_SECRET) as { id: string; email: string; role: string };
    req.user = decoded;
    next();
  } catch (error) {
    console.error("Auth error:", error);
    res.status(401).json({ message: "Invalid or expired token" });
  }
};
// ===== Register
router.post("/register", async (req: Request, res: Response) => {
  try {
    const { name, email, password, confirmPassword } = req.body;

    if (!name || !email || !password || !confirmPassword)
      return res.status(400).json({ message: "All fields are required" });

    if (password !== confirmPassword)
      return res.status(400).json({ message: "Passwords do not match" });

    const passwordRegex =
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-={}[\]|:;"'<>,.?/]).{8,}$/;
    if (!passwordRegex.test(password))
      return res.status(400).json({
        message:
          "Password must have at least 8 characters, one uppercase, one lowercase, one number, and one special character",
      });

    const existingUser = await User.findOne({ email });
    if (existingUser) return res.status(400).json({ message: "User already exists" });

    const hashedPassword = await bcrypt.hash(password, 10);
    const newUser = new User({ name, email, password: hashedPassword, role: "user" });
    await newUser.save();

    res.status(201).json({ message: "User registered successfully" });
  } catch (error) {
    console.error("Register error:", error);
    res.status(500).json({ message: "Error registering user" });
  }
});

// ===== Login
router.post("/login", async (req: Request, res: Response) => {
  try {
    const { email, password } = req.body;

    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "Invalid email or password" });

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) return res.status(400).json({ message: "Invalid email or password" });

    const token = jwt.sign(
      { id: user._id, email: user.email, role: user.role },
      JWT_SECRET,
      { expiresIn: "2h" }
    );

    res.cookie("token", token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "lax",
      maxAge: 2 * 60 * 60 * 1000,
    });

    res.json({
      message: "Login successful",
      user: { id: user._id, name: user.name, email: user.email, role: user.role },
    });
  } catch (error) {
    console.error("Login error:", error);
    res.status(500).json({ message: "Error logging in" });
  }
});

// ===== Logout
router.post("/logout", (_req: Request, res: Response) => {
  res.clearCookie("token", { httpOnly: true, secure: process.env.NODE_ENV === "production", sameSite: "lax" });
  res.json({ message: "Logged out successfully" });
});
// ===== Forgot Password
router.post("/forgot-password", async (req: Request, res: Response) => {
  try {
    const { email } = req.body;
    if (!email) return res.status(400).json({ message: "Email is required" });

    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "User not found" });

    // Ø¥Ù†Ø´Ø§Ø¡ ØªÙˆÙƒÙ† Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù„ÙØªØ±Ø© Ù‚ØµÙŠØ±Ø©
    const resetToken = crypto.randomBytes(32).toString("hex");
    const resetTokenExpiry = new Date(Date.now() + 3600000); // 1 Ø³Ø§Ø¹Ø©

    user.resetPasswordToken = resetToken;
    user.resetPasswordExpires = resetTokenExpiry;
    await user.save();

    // Ù‡Ù†Ø§ Ø¹Ø§Ø¯Ø©Ù‹ ØªØ¨Ø¹Øª Ø§ÙŠÙ…ÙŠÙ„ Ù„Ù„Ø¹Ù…ÙŠÙ„ØŒ Ø­Ø§Ù„ÙŠÙ‹Ø§ Ù†Ø·Ø¨Ø¹ Ø§Ù„Ø±Ø§Ø¨Ø· Ù„Ù„Ù€ dev
    console.log(`Reset link: ${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`);

    res.json({ message: "Reset link sent successfully" });
  } catch (error) {
    console.error("Forgot password error:", error);
    res.status(500).json({ message: "Error processing forgot password" });
  }
});

// ===== Reset Password
router.post("/reset-password", async (req: Request, res: Response) => {
  try {
    const { token, password, confirmPassword } = req.body;
    if (!token || !password || !confirmPassword)
      return res.status(400).json({ message: "All fields are required" });

    if (password !== confirmPassword)
      return res.status(400).json({ message: "Passwords do not match" });

    const passwordRegex =
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-={}[\]|:;"'<>,.?/]).{8,}$/;
    if (!passwordRegex.test(password))
      return res.status(400).json({
        message:
          "Password must have at least 8 characters, one uppercase, one lowercase, one number, and one special character",
      });

    const user = await User.findOne({
      resetPasswordToken: token,
      resetPasswordExpires: { $gt: new Date() },
    });
    if (!user) return res.status(400).json({ message: "Invalid or expired token" });

    user.password = await bcrypt.hash(password, 10);
    user.resetPasswordToken = undefined;
    user.resetPasswordExpires = undefined;

    await user.save();
    res.json({ message: "Password reset successfully" });
  } catch (error) {
    console.log(`Reset link: ${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`);
    console.error("Reset password error:", error);
    console.log(`Reset link: ${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`);
    res.status(500).json({ message: "Error resetting password" });
  }
});

router.post("/change-password", requireAuth, async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });

    const { oldPassword, newPassword, confirmPassword } = req.body;
    if (!oldPassword || !newPassword || !confirmPassword)
      return res.status(400).json({ message: "All fields are required" });

    if (newPassword !== confirmPassword)
      return res.status(400).json({ message: "Passwords do not match" });

    const passwordRegex =
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-={}[\]|:;"'<>,.?/]).{8,}$/;
    if (!passwordRegex.test(newPassword))
      return res.status(400).json({
        message:
          "Password must have at least 8 characters, one uppercase, one lowercase, one number, and one special character",
      });

    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ message: "User not found" });

    const isMatch = await bcrypt.compare(oldPassword, user.password);
    if (!isMatch) return res.status(400).json({ message: "Old password is incorrect" });

    user.password = await bcrypt.hash(newPassword, 10);
    await user.save();

    res.json({ message: "Password changed successfully" });
  } catch (error) {
    console.error("Change password error:", error);
    res.status(500).json({ message: "Error changing password" });
  }
});

// ===== Update Profile
router.put("/update-profile", requireAuth, async (req: AuthRequest, res: Response) => {
  try {
    const { name, email, password, confirmPassword } = req.body;
    const user = await User.findById(req.user!.id);
    if (!user) return res.status(404).json({ message: "User not found" });

    if (name) user.name = name;
    if (email) user.email = email;

    if (password || confirmPassword) {
      if (password !== confirmPassword)
        return res.status(400).json({ message: "Passwords do not match" });

      const now = new Date();
      const oneMonth = 30 * 24 * 60 * 60 * 1000;

      if (user.lastPasswordChange && now.getTime() - user.lastPasswordChange.getTime() < oneMonth)
        return res.status(400).json({ message: "You can only change your password once every 30 days" });

      if (user.passwordChangeCount && user.passwordChangeCount >= 3)
        return res.status(400).json({ message: "Maximum password changes reached (3)" });

      const passwordRegex =
        /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-={}[\]|:;"'<>,.?/]).{8,}$/;
      if (!passwordRegex.test(password))
        return res.status(400).json({
          message:
            "Password must have at least 8 characters, one uppercase, one lowercase, one number, one special character",
        });

      user.password = await bcrypt.hash(password, 10);
      user.lastPasswordChange = now;
      user.passwordChangeCount = (user.passwordChangeCount || 0) + 1;
    }

    await user.save();
    res.json({ message: "Profile updated successfully", user });
  } catch (error) {
    console.error("Update profile error:", error);
    res.status(500).json({ message: "Error updating profile" });
  }
});

// ===== Delete Account
router.delete("/delete-account", requireAuth, async (req: AuthRequest, res: Response) => {
  try {
    const user = await User.findByIdAndDelete(req.user!.id);
    if (!user) return res.status(404).json({ message: "User not found" });

    res.clearCookie("token", { httpOnly: true, secure: process.env.NODE_ENV === "production", sameSite: "lax" });
    res.json({ message: "Account deleted successfully" });
  } catch (error) {
    console.error("Delete account error:", error);
    res.status(500).json({ message: "Error deleting account" });
  }
});

export default router;

*/

/*

import { Router, Request, Response, NextFunction } from "express";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import crypto from "crypto";
import User from "../models/User";
import { requireAuth as verifyToken } from "../middleware/authMiddleware";
//import { verifyToken } from "../middleware/auth"; // Ø¹Ø¯Ù‘Ù„ Ø§Ù„Ù…Ø³Ø§Ø± Ø­Ø³Ø¨ Ù…ÙƒØ§Ù† Ø§Ù„Ù…Ù„Ù
const router = Router();
const JWT_SECRET = process.env.JWT_SECRET || "fallback_secret";

// ===== Middleware: requireAuth
export const requireAuth = async (req: any, res: Response, next: NextFunction) => {
  try {
    const token = req.cookies?.token || req.headers.authorization?.split(" ")[1];
    if (!token) return res.status(401).json({ message: "No token provided" });

    const decoded = jwt.verify(token, JWT_SECRET) as { id: string; email: string; role: string };
    req.user = decoded;
    next();
  } catch (error) {
    console.error("Auth error:", error);
    res.status(401).json({ message: "Invalid or expired token" });
  }
};

// ===== Register
router.post("/register", async (req: Request, res: Response) => {
  try {
    const { name, email, password, confirmPassword } = req.body;

    if (!name || !email || !password || !confirmPassword)
      return res.status(400).json({ message: "All fields are required" });

    if (password !== confirmPassword)
      return res.status(400).json({ message: "Passwords do not match" });

    const passwordRegex =
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-={}[\]|:;"'<>,.?/]).{8,}$/;
    if (!passwordRegex.test(password))
      return res.status(400).json({
        message:
          "Password must have at least 8 characters, one uppercase, one lowercase, one number, and one special character",
      });

    const existingUser = await User.findOne({ email });
    if (existingUser) return res.status(400).json({ message: "User already exists" });

    const hashedPassword = await bcrypt.hash(password, 10);
    const newUser = new User({ name, email, password: hashedPassword, role: "user" });
    await newUser.save();

    res.status(201).json({ message: "User registered successfully" });
  } catch (error) {
    console.error("Register error:", error);
    res.status(500).json({ message: "Error registering user" });
  }
});

// ===== Login
router.post("/login", async (req: Request, res: Response) => {
  try {
    const { email, password } = req.body;

    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "Invalid email or password" });

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) return res.status(400).json({ message: "Invalid email or password" });

    const token = jwt.sign(
      { id: user._id, email: user.email, role: user.role },
      JWT_SECRET,
      { expiresIn: "2h" }
    );

    res.cookie("token", token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "lax",
      maxAge: 2 * 60 * 60 * 1000,
    });

    res.json({
      message: "Login successful",
      user: { id: user._id, name: user.name, email: user.email, role: user.role },
    });
  } catch (error) {
    console.error("Login error:", error);
    res.status(500).json({ message: "Error logging in" });
  }
});

// ===== Logout
router.post("/logout", (_req: Request, res: Response) => {
  res.clearCookie("token", { httpOnly: true, secure: process.env.NODE_ENV === "production", sameSite: "lax" });
  res.json({ message: "Logged out successfully" });
});

// ===== Forgot Password
router.post("/forgot-password", async (req: Request, res: Response) => {
  try {
    const { email } = req.body;
    if (!email) return res.status(400).json({ message: "Email is required" });

    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "User not found" });

    const resetToken = crypto.randomBytes(32).toString("hex");
    const resetTokenExpiry = new Date(Date.now() + 3600000); // 1 hour

    user.resetPasswordToken = resetToken;
    user.resetPasswordExpires = resetTokenExpiry;
    await user.save();

    console.log(`Reset link: ${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`);
    res.json({ message: "Reset link sent successfully" });
  } catch (error) {
    console.error("Forgot password error:", error);
    res.status(500).json({ message: "Error processing forgot password" });
  }
});

// ===== ØªØºÙŠÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
interface AuthRequest extends Request {
  user?: {
    id: string;
    email?: string;
    role?: string;
  };
}

router.post("/change-password", requireAuth, async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });

    const { oldPassword, newPassword, confirmPassword } = req.body;
    if (!oldPassword || !newPassword || !confirmPassword)
      return res.status(400).json({ message: "All fields are required" });

    if (newPassword !== confirmPassword)
      return res.status(400).json({ message: "Passwords do not match" });

    const passwordRegex =
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-={}[\]|:;"'<>,.?/]).{8,}$/;
    if (!passwordRegex.test(newPassword))
      return res.status(400).json({
        message:
          "Password must have at least 8 characters, one uppercase, one lowercase, one number, and one special character",
      });

    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ message: "User not found" });

    const isMatch = await bcrypt.compare(oldPassword, user.password);
    if (!isMatch) return res.status(400).json({ message: "Old password is incorrect" });

    user.password = await bcrypt.hash(newPassword, 10);
    await user.save();

    res.json({ message: "Password changed successfully" });
  } catch (error) {
    console.error("Change password error:", error);
    res.status(500).json({ message: "Error changing password" });
  }
});

// ===== Reset Password
router.post("/reset-password", async (req: Request, res: Response) => {
  try {
    const { token, password, confirmPassword } = req.body;
    if (!token || !password || !confirmPassword)
      return res.status(400).json({ message: "All fields are required" });

    if (password !== confirmPassword)
      return res.status(400).json({ message: "Passwords do not match" });

    const passwordRegex =
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-={}[\]|:;"'<>,.?/]).{8,}$/;
    if (!passwordRegex.test(password))
      return res.status(400).json({
        message:
          "Password must have at least 8 characters, one uppercase, one lowercase, one number, and one special character",
      });

    const user = await User.findOne({
      resetPasswordToken: token,
      resetPasswordExpires: { $gt: new Date() },
    });
    if (!user) return res.status(400).json({ message: "Invalid or expired token" });

    user.password = await bcrypt.hash(password, 10);
    user.resetPasswordToken = undefined;
    user.resetPasswordExpires = undefined;

    await user.save();
    res.json({ message: "Password reset successfully" });
  } catch (error) {
    console.error("Reset password error:", error);
    res.status(500).json({ message: "Error resetting password" });
  }
});

// ===== Update Profile
router.put("/update-profile", requireAuth, async (req: any, res: Response) => {
  try {
    const { name, email, password, confirmPassword } = req.body;
    const user = await User.findById(req.user.id);
    if (!user) return res.status(404).json({ message: "User not found" });

    if (name) user.name = name;
    if (email) user.email = email;

    if (password || confirmPassword) {
      if (password !== confirmPassword)
        return res.status(400).json({ message: "Passwords do not match" });

      const now = new Date();
      const oneMonth = 30 * 24 * 60 * 60 * 1000;

      if (user.lastPasswordChange && now.getTime() - user.lastPasswordChange.getTime() < oneMonth)
        return res.status(400).json({ message: "You can only change your password once every 30 days" });

      if (user.passwordChangeCount && user.passwordChangeCount >= 3)
        return res.status(400).json({ message: "You have reached the maximum number of password changes (3)" });

      const passwordRegex =
        /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-={}[\]|:;"'<>,.?/]).{8,}$/;
      if (!passwordRegex.test(password))
        return res.status(400).json({
          message:
            "Password must have at least 8 characters, one uppercase, one lowercase, one number, one special character",
        });

      user.password = await bcrypt.hash(password, 10);
      user.lastPasswordChange = now;
      user.passwordChangeCount = (user.passwordChangeCount || 0) + 1;
    }

    await user.save();
    res.json({ message: "Profile updated successfully", user });
  } catch (error) {
    console.error("Update profile error:", error);
    res.status(500).json({ message: "Error updating profile" });
  }
});

// ===== Delete Account
router.delete("/delete-account", requireAuth, async (req: any, res: Response) => {
  try {
    const user = await User.findByIdAndDelete(req.user.id);
    if (!user) return res.status(404).json({ message: "User not found" });

    res.clearCookie("token", { httpOnly: true, secure: process.env.NODE_ENV === "production", sameSite: "lax" });
    res.json({ message: "Account deleted successfully" });
  } catch (error) {
    console.error("Delete account error:", error);
    res.status(500).json({ message: "Error deleting account" });
  }
});

export default router;
*/

/*

import { Router } from "express";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import crypto from "crypto";
import User from "../models/User";
import cookieParser from "cookie-parser";

const router = Router();
const JWT_SECRET = process.env.JWT_SECRET || "fallback_secret";

app.use(cookieParser());


// âœ… Register Route
router.post("/register", async (req, res) => {
  try {
    const { name, email, password, confirmPassword } = req.body;

    if (!name || !email || !password || !confirmPassword) {
      return res.status(400).json({ message: "All fields are required" });
    }

    if (password !== confirmPassword) {
      return res.status(400).json({ message: "Passwords do not match" });
    }

    const passwordRegex =
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-={}[\]|:;"'<>,.?/]).{8,}$/;

    if (!passwordRegex.test(password)) {
      return res.status(400).json({
        message:
          "Password must have at least 8 characters, one uppercase, one lowercase, one number, and one special character",
      });
    }

    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: "User already exists" });
    }

    const hashedPassword = await bcrypt.hash(password, 10);

    // ðŸ‘‡ Ø¯Ø§ÙŠÙ…Ù‹Ø§ ÙŠØ¨Ø¯Ø£ ÙƒÙ€ user
    const newUser = new User({ 
      name, 
      email, 
      password: hashedPassword, 
      role: "user" 
    });

    await newUser.save();

    res.status(201).json({ message: "User registered successfully" });
  } catch (error) {
    console.error("Register error:", error);
    res.status(500).json({ message: "Error registering user" });
  }
})

// ===== ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ø¹ ØªØ®Ø²ÙŠÙ† Ø§Ù„ØªÙˆÙƒÙ† ÙÙŠ ÙƒÙˆÙƒÙŠØ²
router.post("/login", async (req, res) => {
  try {
    const { email, password } = req.body;

    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "Invalid email or password" });

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) return res.status(400).json({ message: "Invalid email or password" });

    const token = jwt.sign(
      { id: user._id, email: user.email, role: user.role },
      JWT_SECRET,
      { expiresIn: "2h" }
    );

    // ðŸ‘‡ Ù†Ø®Ø²Ù† Ø§Ù„ØªÙˆÙƒÙ† ÙƒÙ€ HttpOnly cookie
    res.cookie("token", token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production", // HTTPS ÙÙ‚Ø· ÙÙŠ Ø§Ù„Ø¥Ù†ØªØ§Ø¬
      sameSite: "lax",
      maxAge: 2 * 60 * 60 * 1000, // Ø³Ø§Ø¹ØªÙŠÙ†
    });

    res.json({
      message: "Login successful",
      user: { id: user._id, name: user.name, email: user.email, role: user.role },
    });
  } catch (error) {
    console.error("Login error:", error);
    res.status(500).json({ message: "Error logging in" });
  }
});

// ===== ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬
router.post("/logout", (req, res) => {
  res.clearCookie("token", {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "lax",
  });
  res.json({ message: "Logged out successfully" });
});

// ===== Middleware ØªØ¹Ø¯ÙŠÙ„: Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„ØªÙˆÙƒÙ† Ù…Ù† Ø§Ù„ÙƒÙˆÙƒÙŠØ²
export const requireAuth = (req: any, res: Response, next: NextFunction) => {
  try {
    const token = req.cookies.token || req.headers.authorization?.split(" ")[1];

    if (!token) return res.status(401).json({ message: "No token provided" });

    const decoded = jwt.verify(token, JWT_SECRET) as { id: string; email: string; role: string };
    req.user = decoded;
    next();
  } catch (error) {
    console.error("Auth error:", error);
    res.status(401).json({ message: "Invalid or expired token" });
  }
};;

/*

// âœ… Login Route
router.post("/login", async (req, res) => {
  try {
    const { email, password } = req.body;

    const user = await User.findOne({ email });
    if (!user) {
      return res.status(400).json({ message: "Invalid email or password" });
    }

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(400).json({ message: "Invalid email or password" });
    }
    // ðŸ‘‡ Ù†Ø¶ÙŠÙ role ÙÙŠ Ø§Ù„ØªÙˆÙƒÙ†
    const token = jwt.sign(
      { id: user._id, email: user.email, role: user.role },
      JWT_SECRET,
      { expiresIn: "2h" }
    );
    res.json({ 
      message: "Login successful", 
      token,
      user: { id: user._id, name: user.name, email: user.email, role: user.role }
    });
  } catch (error) {
    console.error("Login error:", error);
    res.status(500).json({ message: "Error logging in" });
  }
});


*

// âœ… Forgot Password Route
router.post("/forgot-password", async (req, res) => {
  try {
    const { email } = req.body;
    if (!email) return res.status(400).json({ message: "Email is required" });

    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "User not found" });

    const resetToken = crypto.randomBytes(32).toString("hex");
    const resetTokenExpiry = new Date(Date.now() + 3600000);

    user.resetPasswordToken = resetToken;
    user.resetPasswordExpires = resetTokenExpiry;
    await user.save();

    console.log(`Reset link: ${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`);

    res.json({ message: "Reset link sent successfully" });
  } catch (error) {
    console.error("Forgot password error:", error);
    res.status(500).json({ message: "Error processing forgot password" });
  }
});
// âœ… Reset Password Route
router.post("/reset-password", async (req, res) => {
  try {
    const { token, password, confirmPassword } = req.body;

    if (!token || !password || !confirmPassword)
      return res.status(400).json({ message: "All fields are required" });

    if (password !== confirmPassword)
      return res.status(400).json({ message: "Passwords do not match" });

    const passwordRegex =
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-={}[\]|:;"'<>,.?/]).{8,}$/;
    if (!passwordRegex.test(password))
      return res.status(400).json({
        message:
          "Password must have at least 8 characters, one uppercase, one lowercase, one number, one special character",
      });
    const user = await User.findOne({
      resetPasswordToken: token,
      resetPasswordExpires: { $gt: new Date() },
    });
    if (!user) return res.status(400).json({ message: "Invalid or expired token" });

    user.password = await bcrypt.hash(password, 10);
    user.resetPasswordToken = undefined;
    user.resetPasswordExpires = undefined;

    await user.save();

    res.json({ message: "Password reset successfully" });
  } catch (error) {
    console.error("Reset password error:", error);
    res.status(500).json({ message: "Error resetting password" });
  }
});


// ===== ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ
router.put("/update-profile", requireAuth, async (req: any, res) => {
  try {
    const { name, email, password, confirmPassword } = req.body;

    const user = await User.findById(req.user.id);
    if (!user) return res.status(404).json({ message: "User not found" });

    if (name) user.name = name;
    if (email) user.email = email;

    if (password || confirmPassword) {
      if (password !== confirmPassword) {
        return res.status(400).json({ message: "Passwords do not match" });
      }

      const now = new Date();
      const oneMonth = 30 * 24 * 60 * 60 * 1000;

      if (user.lastPasswordChange && now.getTime() - user.lastPasswordChange.getTime() < oneMonth) {
        return res.status(400).json({
          message: "You can only change your password once every 30 days",
        });
      }

      if (user.passwordChangeCount && user.passwordChangeCount >= 3) {
        return res.status(400).json({
          message: "You have reached the maximum number of password changes (3)",
        });
      }

      const passwordRegex =
        /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-={}[\]|:;"'<>,.?/]).{8,}$/;
      if (!passwordRegex.test(password)) {
        return res.status(400).json({
          message:
            "Password must have at least 8 characters, one uppercase, one lowercase, one number, one special character",
        });
      }

      user.password = await bcrypt.hash(password, 10);
      user.lastPasswordChange = now;
      user.passwordChangeCount = (user.passwordChangeCount || 0) + 1;
    }

    await user.save();
    res.json({ message: "Profile updated successfully", user });
  } catch (error) {
    console.error("Update profile error:", error);
    res.status(500).json({ message: "Error updating profile" });
  }
});

// ===== Ø­Ø°Ù Ø§Ù„Ø­Ø³Ø§Ø¨
router.delete("/delete-account", requireAuth, async (req: any, res) => {
  try {
    const user = await User.findByIdAndDelete(req.user.id);
    if (!user) return res.status(404).json({ message: "User not found" });

    // Ø§Ù…Ø³Ø­ Ø§Ù„ÙƒÙˆÙƒÙŠØ² Ø¨Ø¹Ø¯ Ø­Ø°Ù Ø§Ù„Ø­Ø³Ø§Ø¨
    res.clearCookie("token", {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "lax",
    });

    res.json({ message: "Account deleted successfully" });
  } catch (error) {
    console.error("Delete account error:", error);
    res.status(500).json({ message: "Error deleting account" });
  }
});

/*

// âœ… Update Profile Route
router.put("/update-profile", async (req: any, res) => {
  try {
    const { name, email, password, confirmPassword } = req.body;

    // Ù„Ø§Ø²Ù… ÙŠÙƒÙˆÙ† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¯Ø§Ø®Ù„ (Ù…ØµØ¯Ù‚ Ø¨Ø§Ù„ØªÙˆÙƒÙ†)
    if (!req.user) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    const user = await User.findById(req.user.id);
    if (!user) return res.status(404).json({ message: "User not found" });

    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø§Ø³Ù…/Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„
    if (name) user.name = name;
    if (email) user.email = email;

    // ðŸ‘‡ Ù„Ùˆ Ø¹Ø§ÙŠØ² ÙŠØºÙŠØ± Ø§Ù„Ø¨Ø§Ø³ÙˆØ±Ø¯
    if (password || confirmPassword) {
      if (password !== confirmPassword) {
        return res.status(400).json({ message: "Passwords do not match" });
      }

      const now = new Date();

      // âœ… ØªØ­Ù‚Ù‚: Ù„Ùˆ Ø£Ù‚Ù„ Ù…Ù† Ø´Ù‡Ø± Ù…Ù† Ø¢Ø®Ø± ØªØºÙŠÙŠØ±
      if (user.lastPasswordChange) {
        const oneMonth = 30 * 24 * 60 * 60 * 1000;
        if (now.getTime() - user.lastPasswordChange.getTime() < oneMonth) {
          return res.status(400).json({
            message: "You can only change your password once every 30 days",
          });
        }
      }
      // âœ… ØªØ­Ù‚Ù‚: Ù„Ùˆ Ø¹Ø¯Ù‘Ù‰ 3 Ù…Ø±Ø§Øª
      if (user.passwordChangeCount && user.passwordChangeCount >= 3) {
        return res.status(400).json({
          message: "You have reached the maximum number of password changes (3)",
        });
      }
      const passwordRegex =
        /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-={}[\]|:;"'<>,.?/]).{8,}$/;
      if (!passwordRegex.test(password)) {
        return res.status(400).json({
          message:
            "Password must have at least 8 characters, one uppercase, one lowercase, one number, one special character",
        });
      }
*
      // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨Ø§Ø³ÙˆØ±Ø¯
      user.password = await bcrypt.hash(password, 10);
      user.lastPasswordChange = now;
      user.passwordChangeCount = (user.passwordChangeCount || 0) + 1;
    }

    await user.save();
    res.json({ message: "Profile updated successfully" });
  } catch (error) {
    console.error("Update profile error:", error);
    res.status(500).json({ message: "Error updating profile" });
  }
});

// âœ… Delete Account Route
router.delete("/delete-account", async (req: any, res) => {
  try {
    if (!req.user) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    const user = await User.findByIdAndDelete(req.user.id);
    if (!user) return res.status(404).json({ message: "User not found" });

    res.json({ message: "Account deleted successfully" });
  } catch (error) {
    console.error("Delete account error:", error);
    res.status(500).json({ message: "Error deleting account" });
  }
});


export default router;

*/


/*
// services/auth/routes/auth.ts
import { Router } from "express";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import crypto from "crypto"; // âœ… Ù„Ø§Ø²Ù… Ù†Ø³ØªÙˆØ±Ø¯ Ø¯Ù‡
import User from "../models/User";

const router = Router();
const JWT_SECRET = process.env.JWT_SECRET || "fallback_secret";

// âœ… Register Route
router.post("/register", async (req, res) => {
  try {
    const { name, email, password, confirmPassword } = req.body;

    if (!name || !email || !password || !confirmPassword) {
      return res.status(400).json({ message: "All fields are required" });
    }

    if (password !== confirmPassword) {
      return res.status(400).json({ message: "Passwords do not match" });
    }

    const passwordRegex =
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-={}[\]|:;"'<>,.?/]).{8,}$/;

    if (!passwordRegex.test(password)) {
      return res.status(400).json({
        message:
          "Password must have at least 8 characters, one uppercase, one lowercase, one number, and one special character",
      });
    }

    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: "User already exists" });
    }

    const hashedPassword = await bcrypt.hash(password, 10);

    const newUser = new User({ name, email, password: hashedPassword });
    await newUser.save();

    res.status(201).json({ message: "User registered successfully" });
  } catch (error) {
    console.error("Register error:", error);
    res.status(500).json({ message: "Error registering user" });
  }
});

// âœ… Login Route
router.post("/login", async (req, res) => {
  try {
    const { email, password } = req.body;

    const user = await User.findOne({ email });
    if (!user) {
      return res.status(400).json({ message: "Invalid email or password" });
    }

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(400).json({ message: "Invalid email or password" });
    }

    const token = jwt.sign({ id: user._id, email: user.email }, JWT_SECRET, {
      expiresIn: "1h",
    });

    res.json({ message: "Login successful", token });
  } catch (error) {
    console.error("Login error:", error);
    res.status(500).json({ message: "Error logging in" });
  }
});

// âœ… Forgot Password Route
router.post("/forgot-password", async (req, res) => {
  try {
    const { email } = req.body;
    if (!email) return res.status(400).json({ message: "Email is required" });

    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "User not found" });

    const resetToken = crypto.randomBytes(32).toString("hex");
    const resetTokenExpiry = new Date(Date.now() + 3600000); // 1 Ø³Ø§Ø¹Ø© âœ… Ù†Ø®Ù„ÙŠÙ‡Ø§ Date

    user.resetPasswordToken = resetToken;
    user.resetPasswordExpires = resetTokenExpiry;
    await user.save();

    console.log(`Reset link: ${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`);

    res.json({ message: "Reset link sent successfully" });
  } catch (error) {
    console.error("Forgot password error:", error);
    res.status(500).json({ message: "Error processing forgot password" });
  }
});

// âœ… Reset Password Route
router.post("/reset-password", async (req, res) => {
  try {
    const { token, password, confirmPassword } = req.body;

    if (!token || !password || !confirmPassword)
      return res.status(400).json({ message: "All fields are required" });

    if (password !== confirmPassword)
      return res.status(400).json({ message: "Passwords do not match" });

    const passwordRegex =
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-={}[\]|:;"'<>,.?/]).{8,}$/;
    if (!passwordRegex.test(password))
      return res.status(400).json({
        message:
          "Password must have at least 8 characters, one uppercase, one lowercase, one number, one special character",
      });

    const user = await User.findOne({
      resetPasswordToken: token,
      resetPasswordExpires: { $gt: new Date() }, // âœ… Ù„Ø§Ø²Ù… Date Ù‡Ù†Ø§
    });
    if (!user) return res.status(400).json({ message: "Invalid or expired token" });

    user.password = await bcrypt.hash(password, 10);
    user.resetPasswordToken = undefined;
    user.resetPasswordExpires = undefined;

    await user.save();

    res.json({ message: "Password reset successfully" });
  } catch (error) {
    console.error("Reset password error:", error);
    res.status(500).json({ message: "Error resetting password" });
  }
});

export default router;


*/


/*
// services/auth/routes/auth.ts
import { Router } from "express";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import User from "../models/User";

const router = Router();
const JWT_SECRET = process.env.JWT_SECRET || "fallback_secret";

// âœ… Register Route
router.post("/register", async (req, res) => {
  try {
    const { name, email, password, confirmPassword } = req.body;

    // ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ù‚ÙˆÙ„
    if (!name || !email || !password || !confirmPassword) {
      return res.status(400).json({ message: "All fields are required" });
    }

    // ØªØ£ÙƒÙŠØ¯ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
    if (password !== confirmPassword) {
      return res.status(400).json({ message: "Passwords do not match" });
    }

    // ØªØ­Ù‚Ù‚ Ù…Ù† Ù‚ÙˆØ© Ø§Ù„Ø¨Ø§Ø³ÙˆØ±Ø¯
    const passwordRegex =
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-={}[\]|:;"'<>,.?/]).{8,}$/;

    if (!passwordRegex.test(password)) {
      return res.status(400).json({
        message:
          "Password must have at least 8 characters, one uppercase, one lowercase, one number, and one special character",
      });
    }

    // Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„ØŸ
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: "User already exists" });
    }

    // ØªØ´ÙÙŠØ± Ø§Ù„Ø¨Ø§Ø³ÙˆØ±Ø¯
    const hashedPassword = await bcrypt.hash(password, 10);

    // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    const newUser = new User({ name, email, password: hashedPassword });
    await newUser.save();

    res.status(201).json({ message: "User registered successfully" });
  } catch (error) {
    console.error("Register error:", error);
    res.status(500).json({ message: "Error registering user" });
  }
});

// âœ… Login Route
router.post("/login", async (req, res) => {
  try {
    const { email, password } = req.body;

    // Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…ÙˆØ¬ÙˆØ¯ØŸ
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(400).json({ message: "Invalid email or password" });
    }

    // Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„Ø¨Ø§Ø³ÙˆØ±Ø¯
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(400).json({ message: "Invalid email or password" });
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙˆÙƒÙ†
    const token = jwt.sign({ id: user._id, email: user.email }, JWT_SECRET, {
      expiresIn: "1h",
    });

    res.json({ message: "Login successful", token });
  } catch (error) {
    console.error("Login error:", error);
    res.status(500).json({ message: "Error logging in" });
  }
});


// âœ… Forgot Password Route
router.post("/forgot-password", async (req, res) => {
  try {
    const { email } = req.body;
    if (!email) return res.status(400).json({ message: "Email is required" });

    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "User not found" });

    // Ø¥Ù†Ø´Ø§Ø¡ token Ù…Ø¤Ù‚Øª (ÙŠÙ…ÙƒÙ† ØªØ®Ø²ÙŠÙ†Ù‡ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ ÙˆÙ‚Øª Ø§Ù†ØªÙ‡Ø§Ø¡)
    const resetToken = crypto.randomBytes(32).toString("hex");
    const resetTokenExpiry = Date.now() + 3600000; // 1 Ø³Ø§Ø¹Ø©

    user.resetPasswordToken = resetToken;
    user.resetPasswordExpires = resetTokenExpiry;
    await user.save();

    // Ù‡Ù†Ø§ Ù…ÙØ±ÙˆØ¶ ØªØ¨Ø¹Øª Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ Ù„Ù„Ù€ user.email ÙŠØ­ØªÙˆÙŠ Ø§Ù„Ø±Ø§Ø¨Ø·:
    // `${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`
    // Ù…Ø«Ø§Ù„: console.log
    console.log(`Reset link: ${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`);

    res.json({ message: "Reset link sent successfully" });
  } catch (error) {
    console.error("Forgot password error:", error);
    res.status(500).json({ message: "Error processing forgot password" });
  }
});

// âœ… Reset Password Route
router.post("/reset-password", async (req, res) => {
  try {
    const { token, password, confirmPassword } = req.body;

    if (!token || !password || !confirmPassword)
      return res.status(400).json({ message: "All fields are required" });

    if (password !== confirmPassword)
      return res.status(400).json({ message: "Passwords do not match" });

    const passwordRegex =
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-={}[\]|:;"'<>,.?/]).{8,}$/;
    if (!passwordRegex.test(password))
      return res.status(400).json({
        message:
          "Password must have at least 8 characters, one uppercase, one lowercase, one number, one special character",
      });

    const user = await User.findOne({
      resetPasswordToken: token,
      resetPasswordExpires: { $gt: Date.now() },
    });
    if (!user) return res.status(400).json({ message: "Invalid or expired token" });

    // ØªØ´ÙÙŠØ± Ø§Ù„Ø¨Ø§Ø³ÙˆØ±Ø¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯
    user.password = await bcrypt.hash(password, 10);
    user.resetPasswordToken = undefined;
    user.resetPasswordExpires = undefined;

    await user.save();

    res.json({ message: "Password reset successfully" });
  } catch (error) {
    console.error("Reset password error:", error);
    res.status(500).json({ message: "Error resetting password" });
  }
});

export default router;


*/
